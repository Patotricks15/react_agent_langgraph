from langchain.chat_models import ChatOpenAI
from langchain.schema import HumanMessage
from langgraph.graph import StateGraph, END
from pydantic import BaseModel

# Define the schema for our agent's state
class AgentState(BaseModel):
    input_text: str       # The user's input or problem statement
    thought: str          # The intermediate reasoning produced by the "reasoning" step
    output_action: str    # The final action plan generated by the "action" step

# Initialize the OpenAI chat model
llm = ChatOpenAI(model="gpt-3.5-turbo-1106", temperature=0)

def reasoning_agent(state: AgentState) -> AgentState:
    """
    The reasoning agent is the first step in the workflow. It takes user's input
    and uses the language model to generate intermediate reasoning. The output
    is stored in the "thought" field of the state.

    Args:
        state (AgentState): The current state of the agent.

    Returns:
        AgentState: The updated state of the agent.
    """
    response = llm([HumanMessage(content=f"Think step by step: {state.input_text}")])
    return AgentState(
        input_text=state.input_text,
        thought=response.content,   # Save the model's reasoning here
        output_action=state.output_action
    )

def action_agent(state: AgentState) -> AgentState:
    """
    The action agent is the second step in the workflow. It takes the user's
    input and the intermediate reasoning from the previous step, and uses the
    language model to generate a final action plan. The output is stored in the
    "output_action" field of the state.

    Args:
        state (AgentState): The current state of the agent.

    Returns:
        AgentState: The updated state of the agent.
    """
    response = llm([HumanMessage(
        content=f"Based on the problem: {state.input_text}, and the thought {state.thought}, build an action plan"
    )])
    return AgentState(
        input_text=state.input_text,
        thought=state.thought,
        output_action=response.content  # Save the final plan here
    )

# Set up the workflow graph with our two nodes
workflow = StateGraph(state_schema=AgentState)
workflow.set_entry_point("reasoning")
workflow.add_node("reasoning", reasoning_agent)
workflow.add_node("action", action_agent)
workflow.add_edge("reasoning", "action")
workflow.add_edge("action", END)

# Compile the graph into an executable workflow
graph = workflow.compile()

# Prepare initial state with the user's request
user_input = "Build a 3-months plan to study the basics of English language"
initial_state = AgentState(
    input_text=user_input,
    thought="",
    output_action=""
)

# Invoke the workflow to run both nodes in sequence
result = graph.invoke(initial_state)

# Generate and save a visualization of the graph structure
png_bytes = graph.get_graph(xray=1).draw_mermaid_png()
with open("react_agent_graph.png", "wb") as f:
    f.write(png_bytes)

# Output the final state (including thought and action plan)
print(result)
